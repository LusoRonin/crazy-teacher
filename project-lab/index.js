// IMPORTS
require('dotenv').config();
const express = require("express");
const cors = require("cors");
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const fs = require('fs');
const app = express();
const https = require('https');
const fetch = require('node-fetch');
const mysql = require('mysql');

const PORT = 3002; // SETS PORT
// STARTS SERVER
app.use(cors());
app.options('*', cors())
app.use(express());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

var con = mysql.createConnection({
    host: "localhost",
    user: "root",
    password: "password",
    database: "DATABASE"
});
con.connect(function (err) {
    if (err) {
        console.log("ERROR CONNECTING TO DATABASE!");
        throw err;
    } 
    console.log("CONNECTED TO DATABASE!");
});

// PATHS:
// /USER

// ASYNC FUNCTION SELECT: SELECTS A USER FROM THE DATABASE WITH THE PROVIDED NAME
// PARAMETERS: NAME
// RETURNS: USER
// RETURNS NULL IF NO USER IS FOUND
async function select(name) {
    let final_result = await new Promise((resolve, _) => {
        con.query("SELECT * FROM USERS WHERE NAME = '" + name + "'", function (err, result) {
            if (err) throw err;
            resolve(result[0]);
        });
    }).catch((err) => {
        reject(null);
    });
    return final_result;
}

// FUNCTION INSERT: INSERTS A USER INTO THE DATABASE WITH THE PROVIDED NAME AND TOKEN
// PARAMETERS: NAME, TOKEN
// RETURNS: TRUE IF THE USER WAS INSERTED; FALSE IF THE USER WAS NOT INSERTED
async function insert(name, token) {
    let result = await new Promise((resolve, _) => {
        con.query("INSERT INTO USERS VALUES ('" + name + "', '" + token + "')", function (err, result) {
            if (err) throw err;
            resolve(result);
        });
    }).catch((err) => {
        reject(null);
    });
    return result;
}

// FUNCTION TO CHECK VALIDATE A TOKEN AND RETURN THE USER 
function VALIDATE(TOKEN) { // VALIDATES A TOKEN 
    let USER = jwt.verify(TOKEN, process.env.SECRET_TOKEN); // VERIFIES THE TOKEN 
    if (USER) { // IF THE TOKEN IS VALID 
        return USER; // RETURNS THE USER 
    } else { // IF THE TOKEN IS NOT VALID 
        return null; // RETURNS FALSE 
    }
}

// API RESPONSE INDEX:
// 200 OK: REQUEST ACCEPTED, RESPONSE CONTAINS RESULT. THIS IS A GENERAL PURPOSE RESPONSE CODE THAT CAN BE RETURNED FROM ANY REQUEST. FOR GET REQUESTS, THE REQUESTED RESOURCE OR DATA IS IN THE RESPONSE BODY. FOR PUT OR DELETE REQUESTS, THE REQUEST WAS SUCCESSFUL AND INFORMATION ABOUT THE RESULT (SUCH AS NEW RESOURCE IDENTIFIERS, OR CHANGES IN RESOURCE STATUS) CAN BE FOUND IN THE RESPONSE BODY.
// 201 CREATED: THIS RESPONSE CODE IS RETURNED FROM PUT OR POST, AND INDICATES THAT A NEW RESOURCE WAS CREATED SUCCESSFULLY. THE RESPONSE BODY MIGHT FOR EXAMPLE CONTAIN INFORMATION ABOUT A NEW RESOURCE, OR VALIDATION INFORMATION (FOR EXAMPLE, WHEN AN ASSET IS UPDATED).
// 204 NO CONTENT: INDICATES THAT THE REQUEST WAS ACCEPTED BUT THAT THERE WAS NOTHING TO RETURN. THIS IS RETURNED WHEN THE REQUEST WAS PROCESSED, BUT NO ADDITIONAL INFORMATION ABOUT THE RESULT HAS BEEN RETURNED.
// 400 BAD REQUEST: THE REQUEST WAS NOT VALID. THIS CODE IS RETURNED WHEN THE SERVER HAS ATTEMPTED TO PROCESS THE REQUEST, BUT SOME ASPECT OF THE REQUEST IS NOT VALID, FOR EXAMPLE AN INCORRECTLY FORMATTED RESOURCE OR AN ATTEMPT TO DEPLOY AN INVALID EVENT PROJECT TO THE EVENT RUNTIME. INFORMATION ABOUT THE REQUEST IS PROVIDED IN THE RESPONSE BODY, AND INCLUDES AN ERROR CODE AND ERROR MESSAGE.
// 401 UNAUTHORIZED: IS RETURNED FROM THE APPLICATION SERVER WHEN APPLICATION SECURITY IS ENABLED, AND AUTHORIZATION INFORMATION WAS MISSING FROM THE REQUEST.
// 403 FORBIDDEN: INDICATES THAT THE CLIENT ATTEMPTED TO ACCESS A RESOURCE WHICH THEY DO NOT HAVE ACCESS TO. THIS MIGHT BE ENCOUNTERED IF THE USER ACCESSING THE REMOTE RESOURCE DOES NOT HAVE SUFFICIENT PRIVILEGES; FOR EXAMPLE, BY HAVING THE WBERESTAPIUSERS OR WBERESTAPIPRIVILEGEDUSERS ROLE. USERS WHO ATTEMPT TO ACCESS PRIVATE EVENT PROJECTS OWNED BY OTHER USERS MIGHT ALSO SEE THIS ERROR, BUT ONLY IF THEY HAVE THE WBERESTAPIUSERS ROLE RATHER THAN THE WBERESTAPIPRIVILEGEDUSERS ROLE.
// 404 NOT FOUND: INDICATES THAT THE TARGETED RESOURCE DOES NOT EXIST. THIS MIGHT BE BECAUSE THE URI IS MALFORMED, OR THE RESOURCE HAS BEEN DELETED.
// 405 METHOD NOT ALLOWED: RETURNED WHEN THE TARGETED RESOURCE DOES NOT SUPPORT THE REQUESTED HTTP METHOD; FOR EXAMPLE, THE FUNCTIONS RESOURCE ONLY ALLOWS GET OPERATIONS.
// 406 NOT ACCEPTABLE: THE DATA FORMAT REQUESTED IN THE ACCEPT HEADER OR ACCEPT PARAMETER IS NOT SUPPORTED BY THE TARGETED RESOURCE. THAT IS, THE CLIENT HAS REQUESTED THAT DATA IS RETURNED IN A PARTICULAR FORMAT, BUT THE SERVER IS UNABLE TO RETURN DATA IN THAT FORMAT.
// 409 CONFLICT: INDICATES THAT A CONFLICTING CHANGE HAS BEEN DETECTED DURING AN ATTEMPT TO MODIFY A RESOURCE. THE RESPONSE BODY PROVIDES FURTHER INFORMATION.
// 415 UNSUPPORTED MEDIA TYPE: THE DATA FORMAT OF THE REQUEST BODY, SPECIFIED IN THE CONTENT-TYPE HEADER, IS UNSUPPORTED BY THE TARGETED RESOURCE.
// 500 INTERNAL SERVER ERROR: AN INTERNAL ERROR OCCURRED IN THE SERVER. THIS MIGHT INDICATE A PROBLEM WITH THE REQUEST, OR MIGHT INDICATE A PROBLEM IN THE SERVER SIDE CODE. ERROR INFORMATION CAN BE FOUND IN THE RESPONSE BODY.
// 503 SERVICE UNAVAILABLE: THE SERVER IS UNABLE TO PROCESS THE REQUEST AT THIS TIME. THIS MIGHT BE TEMPORARY, AND THE SERVER MAY BE ABLE TO PROCESS THE REQUEST AT A LATER TIME.

// CHECKS IF THERE'S A USER WITH THE PROVIDED NAME: /USER?NAME=:NAME
// IF THE NAME IS PROVIDED, CHECKS THE NAME; IF THEY ARE CORRECT, SENDS A 200 OK RESPONSE; OTHERWISE, SEND A 400 BAD REQUEST RESPONSE (NO NAME PROVIDED) OR 404 NOT FOUND RESPONSE (NAME NOT FOUND)
// AUTHENTICATES THE USER: /USER?NAME=:NAME&PIN=:PIN
// IF THE NAME AND PIN ARE PROVIDED, CHECKS IF THE NAME AND PIN ARE CORRECT; IF THEY ARE CORRECT, SENDS A 200 OK RESPONSE AND USER (REPLACING THE PIN FIELD WITH THE TOKEN); OTHERWISE, SEND A 401 UNAUTHORIZED RESPONSE (BAD PIN) OR A 400 BAD REQUEST RESPONSE (NO NAME OR PIN PROVIDED) OR 404 NOT FOUND RESPONSE (NAME NOT FOUND)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.get("/USER", cors(), async (req, res) => {
    // try {
    if (req.query.NAME && !req.query.PIN) { // IF THE NAME IS PROVIDED
        let DATABASE_USER = await select(req.query.NAME); // SELECTS THE USER WITH THE PROVIDED NAME
        if (DATABASE_USER) { // IF THE USER EXISTS
            // SENDS A 200 OK RESPONSE AND THE USER WITHOUT THE TOKEN
            res.status(200).send({ // SENDS A 200 OK RESPONSE
                NAME: DATABASE_USER.NAME
            });
        } else { // IF THE USER DOESN'T EXIST
            res.status(404).send("NOT FOUND"); // SENDS A 404 NOT FOUND RESPONSE
        }
    } else if (req.query.NAME && req.query.PIN) { // IF THE NAME AND PIN ARE PROVIDED
        let DATABASE_USER = await select(req.query.NAME); // SELECTS THE USER WITH THE PROVIDED NAME
        let RECEIVED_USER = { // CREATES A RECEIVED USER OBJECT
            NAME: req.query.NAME,
            PIN: req.query.PIN
        }
        if (DATABASE_USER) { // IF THE USER IS FOUND
            let DATABASE_GENERATED_USER = VALIDATE(DATABASE_USER.TOKEN); // VALIDATES THE USER TOKEN
            if (DATABASE_GENERATED_USER) { // IF THE USER TOKEN IS VALID
                if (DATABASE_GENERATED_USER.NAME === RECEIVED_USER.NAME && DATABASE_GENERATED_USER.PIN === RECEIVED_USER.PIN) { // IF THE NAME AND PIN ARE CORRECT
                    res.status(200).send(DATABASE_USER); // SENDS A 200 OK RESPONSE WITH THE USER
                } else { // IF THE NAME AND PIN ARE NOT CORRECT
                    res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
                }
            } else { // IF THE USER TOKEN IS NOT VALID
                res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
            }
        } else { // IF THE USER IS NOT FOUND
            res.status(404).send("NOT FOUND"); // SENDS A 404 NOT FOUND RESPONSE
        }
    } else { // IF THE NAME IS NOT PROVIDED
        res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
    }
    // } catch (error) { // IF THERE IS AN ERROR
    //     res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    // }
});

// ADD A USER: /USER
// BODY: {
//     "NAME": "",
//     "PIN": ""
// }
// IF THE NAME, PIN ARE PROVIDED, CHECKS IF THE NAME IS ALREADY TAKEN; IF IT IS NOT TAKEN, AND IF THE NAME IS EXACTLY 5 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), AND IF THE PIN IS EXACTLY 4 NUMBERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), ADDS THE USER TO THE DATABASE, AND SENDS A 201 OK CREATED RESPONSE AND THE TOKEN; OTHERWISE, SEND A 400 BAD REQUEST RESPONSE (NO NAME OR PIN PROVIDED) OR A 409 CONFLICT RESPONSE (NAME ALREADY TAKEN) OR A 422 UNPROCESSABLE ENTITY RESPONSE (IF THE NAME IS DIFERRENT FROM 5 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), AND IF THE PIN IS DIFERRENT FROM 4 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM))
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.post("/USER", cors(), async (req, res) => {
    try {
        if (req.body.NAME && req.body.PIN) { // IF THE NAME, PIN ARE PROVIDED
            let USER = await select(req.body.NAME); // SELECTS THE USER WITH THE PROVIDED NAME
            if (!USER) { // IF THE USER IS NOT FOUND
                if (req.body.NAME.trim().length === 5 && req.body.NAME.trim() !== "" && req.body.NAME.trim() !== null && req.body.PIN.trim().length === 4 && req.body.PIN.trim() !== "" && req.body.PIN.trim() !== null) { // IF THE NAME IS DIFERRENT FROM 5 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), AND IF THE PIN IS DIFERRENT FROM 4 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM)
                    let USER = { // CREATES A USER
                        "NAME": req.body.NAME,
                        "PIN": req.body.PIN
                    }; // END CREATES A USER
                    let TOKEN = jwt.sign(USER, process.env.SECRET_TOKEN); // CREATES A TOKEN
                    let NEW_USER_OBJECT = {
                        "NAME": USER.NAME,
                        "TOKEN": TOKEN
                    }; // CREATES A NEW USER OBJECT (REPLACING THE PIN FIELD WITH THE TOKEN)
                    await insert(NEW_USER_OBJECT.NAME, NEW_USER_OBJECT.TOKEN); // ADDS THE USER TO THE DATABASE
                    res.status(201).send(NEW_USER_OBJECT); // SENDS A 201 OK CREATED RESPONSE AND THE USER (REPLACING THE PIN FIELD WITH THE TOKEN)
                } else {
                    res.status(422).send("UNPROCESSABLE ENTITY"); // SENDS A 422 UNPROCESSABLE ENTITY RESPONSE
                }
            } else {
                res.status(409).send("CONFLICT"); // SENDS A 409 CONFLICT RESPONSE
            }
        } else {
            res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// REDITECTS ALL HTTP REQUESTS TO HTTPS REQUESTS
app.use((req, res, next) => {
    if (req.secure) { // IF THE REQUEST IS SECURE
        next(); // IF THE REQUEST IS SECURE
    } else { // IF THE REQUEST IS NOT SECURE
        res.redirect('https://' + req.headers.host + req.url); // REDITECTS ALL HTTP REQUESTS TO HTTPS REQUESTS
    } // END IF
}); // END REDITECTS ALL HTTP REQUESTS TO HTTPS REQUESTS
app.use(express.static('public')); // USES PUBLIC FOLDER

const SECURE_SERVER = https.createServer({
    key: fs.readFileSync('cert/key.pem'),
    cert: fs.readFileSync('cert/certificate.pem')
}, app)
SECURE_SERVER.listen(PORT, () => { // LISTENS TO PORT
    // PRINT THE PORT TO THE CONSOLE
    console.log(`SERVER STARTED ON PORT ${PORT}`);
}); // END STARTS SERVER