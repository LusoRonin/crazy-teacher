// IMPORTS
require('dotenv').config();
const express = require("express");
const cors = require("cors");
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const fs = require('fs');
const app = express();
const https = require('https');

const PORT = 3002; // SETS PORT
// STARTS SERVER
app.use(cors());
app.options('*', cors())
app.use(express());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// DATABASES'
let PRODUCTS = require("./databases/PRODUCTS.json"); // IMPORTS THE PRODUCTS
let CATEGORIES = require("./databases/CATEGORIES.json"); // IMPORTS THE CATEGORIES
let USERS = require("./databases/USERS.json"); // IMPORTS THE USERS
let CARTS = require("./databases/CARTS.json"); // IMPORTS THE CARTS

// PATHS:
// /CATEGORY
// /PRODUCT
// /USER
// /CART

// DATABASE PATHS:
// databases/PRODUCTS.json
// databases/CATEGORIES.json
// databases/USERS.json
// databases/CARTS.json

// REQUIERED FUNCTIONS:
// FUNCTION TO UPDATE A GIVEN DATABASE
function UPDATE_DATA(FILE, NEW_OBJECT) {
    // WRITES THE NEW OBJECT TO THE DATABASE
    fs.writeFile(FILE, JSON.stringify(NEW_OBJECT, null, 4), 'utf8', error => { // UPDATES THE DATABASE
        if (error) { // IF THERE IS AN ERROR, THROW IT
            throw error;
        }
    })
}

// FUNCTION TO CHECK VALIDATE A TOKEN AND RETURN THE USER
function VALIDATE(TOKEN) { // VALIDATES A TOKEN
    let USER = jwt.verify(TOKEN, process.env.SECRET_TOKEN); // VERIFIES THE TOKEN
    if (USER) { // IF THE TOKEN IS VALID
        return USER; // RETURNS THE USER
    } else { // IF THE TOKEN IS NOT VALID
        return null; // RETURNS FALSE
    }
}

// FUNCTION TO CHECK IF A USER IS ADMIN
function IS_ADMIN(TOKEN) { // CHECKS IF A USER IS ADMIN
    let USER = VALIDATE(TOKEN); // VALIDATES THE TOKEN
    if (USER) { // IF THE TOKEN IS VALID
        if (USER.IS_ADMIN) { // IF THE USER IS ADMIN
            return true; // RETURNS TRUE
        } else { // IF THE USER IS NOT ADMIN
            return false; // RETURNS FALSE
        }
    } else { // IF THE TOKEN IS NOT VALID
        return false; // RETURNS FALSE
    }
}

// API RESPONSE INDEX:
// 200 OK: REQUEST ACCEPTED, RESPONSE CONTAINS RESULT. THIS IS A GENERAL PURPOSE RESPONSE CODE THAT CAN BE RETURNED FROM ANY REQUEST. FOR GET REQUESTS, THE REQUESTED RESOURCE OR DATA IS IN THE RESPONSE BODY. FOR PUT OR DELETE REQUESTS, THE REQUEST WAS SUCCESSFUL AND INFORMATION ABOUT THE RESULT (SUCH AS NEW RESOURCE IDENTIFIERS, OR CHANGES IN RESOURCE STATUS) CAN BE FOUND IN THE RESPONSE BODY.
// 201 CREATED: THIS RESPONSE CODE IS RETURNED FROM PUT OR POST, AND INDICATES THAT A NEW RESOURCE WAS CREATED SUCCESSFULLY. THE RESPONSE BODY MIGHT FOR EXAMPLE CONTAIN INFORMATION ABOUT A NEW RESOURCE, OR VALIDATION INFORMATION (FOR EXAMPLE, WHEN AN ASSET IS UPDATED).
// 204 NO CONTENT: INDICATES THAT THE REQUEST WAS ACCEPTED BUT THAT THERE WAS NOTHING TO RETURN. THIS IS RETURNED WHEN THE REQUEST WAS PROCESSED, BUT NO ADDITIONAL INFORMATION ABOUT THE RESULT HAS BEEN RETURNED.
// 400 BAD REQUEST: THE REQUEST WAS NOT VALID. THIS CODE IS RETURNED WHEN THE SERVER HAS ATTEMPTED TO PROCESS THE REQUEST, BUT SOME ASPECT OF THE REQUEST IS NOT VALID, FOR EXAMPLE AN INCORRECTLY FORMATTED RESOURCE OR AN ATTEMPT TO DEPLOY AN INVALID EVENT PROJECT TO THE EVENT RUNTIME. INFORMATION ABOUT THE REQUEST IS PROVIDED IN THE RESPONSE BODY, AND INCLUDES AN ERROR CODE AND ERROR MESSAGE.
// 401 UNAUTHORIZED: IS RETURNED FROM THE APPLICATION SERVER WHEN APPLICATION SECURITY IS ENABLED, AND AUTHORIZATION INFORMATION WAS MISSING FROM THE REQUEST.
// 403 FORBIDDEN: INDICATES THAT THE CLIENT ATTEMPTED TO ACCESS A RESOURCE WHICH THEY DO NOT HAVE ACCESS TO. THIS MIGHT BE ENCOUNTERED IF THE USER ACCESSING THE REMOTE RESOURCE DOES NOT HAVE SUFFICIENT PRIVILEGES; FOR EXAMPLE, BY HAVING THE WBERESTAPIUSERS OR WBERESTAPIPRIVILEGEDUSERS ROLE. USERS WHO ATTEMPT TO ACCESS PRIVATE EVENT PROJECTS OWNED BY OTHER USERS MIGHT ALSO SEE THIS ERROR, BUT ONLY IF THEY HAVE THE WBERESTAPIUSERS ROLE RATHER THAN THE WBERESTAPIPRIVILEGEDUSERS ROLE.
// 404 NOT FOUND: INDICATES THAT THE TARGETED RESOURCE DOES NOT EXIST. THIS MIGHT BE BECAUSE THE URI IS MALFORMED, OR THE RESOURCE HAS BEEN DELETED.
// 405 METHOD NOT ALLOWED: RETURNED WHEN THE TARGETED RESOURCE DOES NOT SUPPORT THE REQUESTED HTTP METHOD; FOR EXAMPLE, THE FUNCTIONS RESOURCE ONLY ALLOWS GET OPERATIONS.
// 406 NOT ACCEPTABLE: THE DATA FORMAT REQUESTED IN THE ACCEPT HEADER OR ACCEPT PARAMETER IS NOT SUPPORTED BY THE TARGETED RESOURCE. THAT IS, THE CLIENT HAS REQUESTED THAT DATA IS RETURNED IN A PARTICULAR FORMAT, BUT THE SERVER IS UNABLE TO RETURN DATA IN THAT FORMAT.
// 409 CONFLICT: INDICATES THAT A CONFLICTING CHANGE HAS BEEN DETECTED DURING AN ATTEMPT TO MODIFY A RESOURCE. THE RESPONSE BODY PROVIDES FURTHER INFORMATION.
// 415 UNSUPPORTED MEDIA TYPE: THE DATA FORMAT OF THE REQUEST BODY, SPECIFIED IN THE CONTENT-TYPE HEADER, IS UNSUPPORTED BY THE TARGETED RESOURCE.
// 500 INTERNAL SERVER ERROR: AN INTERNAL ERROR OCCURRED IN THE SERVER. THIS MIGHT INDICATE A PROBLEM WITH THE REQUEST, OR MIGHT INDICATE A PROBLEM IN THE SERVER SIDE CODE. ERROR INFORMATION CAN BE FOUND IN THE RESPONSE BODY.
// 503 SERVICE UNAVAILABLE: THE SERVER IS UNABLE TO PROCESS THE REQUEST AT THIS TIME. THIS MIGHT BE TEMPORARY, AND THE SERVER MAY BE ABLE TO PROCESS THE REQUEST AT A LATER TIME.

// API ENDPOINTS:
// GET ALL CATEGORIES: /CATEGORY
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.get("/CATEGORY", cors(), (_req, res) => {
    try {
        res.status(200).send(CATEGORIES); // SENDS THE CATEGORIES
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// ADD A CATEGORY: /CATEGORY
// BODY:
// { 
//     "NAME": "", 
//     "DESCRIPTION": "" 
// }
// AUTHENTICATION TOKEN REQUIRED IN THE HEADER: "TOKEN"; USES VALIDATE TOKEN FUNCTION TO CHECK IF THE TOKEN IS VALID
// IF VALIDATED, ADD THE CATEGORY AND UPDATES THE DATABASE, AND SENDS A 201 OK CREATED RESPONSE; OTHERWISE, SEND A 401 UNAUTHORIZED RESPONSE
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.post("/CATEGORY", cors(), (req, res) => {
    try {
        if (IS_ADMIN(req.headers.token)) { // IF VALIDATED AND IS ADMIN
            const CATEGORY = req.body; // GET THE CATEGORY FROM THE BODY
            if (CATEGORY.NAME && CATEGORY.DESCRIPTION) { // IF THE NAME AND DESCRIPTION ARE PROVIDED
                CATEGORIES.push(CATEGORY); // ADD THE CATEGORY TO THE CATEGORIES
                UPDATE_DATA("./databases/CATEGORIES.json", CATEGORIES); // UPDATE THE DATABASE
                res.status(201).send("OK CREATED"); // SEND A 201 CREATED RESPONSE
            } else {
                res.status(400).send("BAD REQUEST"); // SEND A 400 BAD REQUEST RESPONSE
            }
        } else {
            res.status(401).send("UNAUTHORIZED"); // SEND A 401 UNAUTHORIZED RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SEND A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// DELETE A CATEGORY BY NAME: /CATEGORY?NAME=:NAME (NAME QUERY PARAMETER REQUIRED)
// AUTHENTICATION TOKEN REQUIRED IN THE HEADER: "TOKEN"; USES VALIDATE TOKEN FUNCTION TO CHECK IF THE TOKEN IS VALID
// IF VALIDATED, DELETE THE CATEGORY AND UPDATES THE DATABASE, AND SENDS A 204 NO CONTENT RESPONSE; OTHERWISE, SEND A 401 UNAUTHORIZED RESPONSE OR SENDS A 400 BAD REQUEST RESPONSE IF THE NAME IS NOT PROVIDED
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.delete("/CATEGORY", cors(), (req, res) => {
    try {
        if (IS_ADMIN(req.headers.token)) { // IF VALIDATED AND IS ADMIN
            if (req.query.NAME) { // IF THE NAME IS PROVIDED
                CATEGORIES = CATEGORIES.filter(category => category.NAME !== req.query.NAME); // DELETES THE CATEGORY
                PRODUCTS = PRODUCTS.filter(product => product.CATEGORY !== req.query.NAME); // DELETES THE PRODUCTS WITH THE PROVIDED CATEGORY
                UPDATE_DATA("./databases/CATEGORIES.json", CATEGORIES); // UPDATES THE DATABASE
                UPDATE_DATA("./databases/PRODUCTS.json", PRODUCTS); // UPDATES THE DATABASE
                res.status(204).send("NO CONTENT"); // SENDS A 204 NO CONTENT RESPONSE
            } else { // IF THE NAME IS NOT PROVIDED
                res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
            }
        } else { // IF NOT VALIDATED
            res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// GET ALL PRODUCTS: /PRODUCT; /PRODUCT?CATEGORY=:CATEGORY; /PRODUCT?ID=:ID ; /PRODUCT?NAME=:NAME
// IF THE CATEGORY IS PROVIDED, SEND THE PRODUCTS WITH THE PROVIDED CATEGORY; IF THE ID IS PROVIDED, SEND THE PRODUCT WITH THE PROVIDED ID; OTHERWISE, SEND ALL THE PRODUCTS
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.get("/PRODUCT", cors(), (req, res) => {
    try {
        if (req.query.CATEGORY) { // IF THE CATEGORY IS PROVIDED
            res.status(200).send(PRODUCTS.filter(product => product.CATEGORY === req.query.CATEGORY)); // SENDS THE PRODUCTS WITH THE PROVIDED CATEGORY
        } else if (req.query.ID) { // IF THE ID IS PROVIDED
            res.status(200).send(PRODUCTS.filter(product => product.ID === req.query.ID)); // SENDS THE PRODUCT WITH THE PROVIDED ID
        } else if (req.query.NAME) { // IF THE NAME IS PROVIDED
            res.status(200).send(PRODUCTS.filter(product => product.NAME === req.query.NAME)); // SENDS THE PRODUCT WITH THE PROVIDED NAME
        } else { // IF THE CATEGORY, ID, AND NAME ARE NOT PROVIDED
            res.status(200).send(PRODUCTS); // SENDS ALL THE PRODUCTS
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// ADD A PRODUCT: /PRODUCT
// BODY: {
//     "NAME": "",
//     "CATEGORY": "",
//     "DESCRIPTION": "",
//     "IMAGE_URL": "",
//     "PRICE": 0.00,
// }
// AUTHENTICATION TOKEN REQUIRED IN THE HEADER: "TOKEN"; USES VALIDATE TOKEN FUNCTION TO CHECK IF THE TOKEN IS VALID
// IF VALIDATED, CREATES THE PRODUCT AND UPDATES THE DATABASE, AND SENDS A 201 OK CREATED RESPONSE; OTHERWISE, SEND A 401 UNAUTHORIZED RESPONSE OR SENDS A 400 BAD REQUEST RESPONSE IF THE BODY IS NOT PROVIDED
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.post("/PRODUCT", cors(), (req, res) => {
    try {
        if (IS_ADMIN(req.headers.token)) { // IF THE TOKEN IS VALID AND IS ADMIN
            if (req.body.NAME && req.body.CATEGORY && req.body.DESCRIPTION && req.body.IMAGE_URL && req.body.PRICE) { // IF THE BODY IS PROVIDED
                req.body.ID = req.body.NAME.toLowerCase().replace(/ /g, "_"); // CREATES AN ID FOR THE PRODUCT BY SETTING IT'S NAME TO LOWERCASE AND REPLACING ALL THE SPACES WITH UNDERSCORES
                PRODUCTS.push(req.body); // ADDS THE PRODUCT TO THE PRODUCTS ARRAY
                UPDATE_DATA("./databases/PRODUCTS.json", PRODUCTS) // UPDATES THE DATABASE
                res.status(201).send("OK CREATED"); // SENDS A 201 OK CREATED RESPONSE
            } else { // IF THE BODY IS NOT PROVIDED
                res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
            }
        } else { // IF THE TOKEN IS NOT VALID
            res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// DELETE A PRODUCT BY ID: /PRODUCT?ID=:ID (ID QUERY PARAMETER REQUIRED); /PRODUCT?NAME=:NAME (NAME QUERY PARAMETER REQUIRED)
// AUTHENTICATION TOKEN REQUIRED IN THE HEADER: "TOKEN"; USES VALIDATE TOKEN FUNCTION TO CHECK IF THE TOKEN IS VALID
// IF VALIDATED, DELETE THE PRODUCT AND UPDATES THE DATABASE, AND SENDS A 204 NO CONTENT RESPONSE; OTHERWISE, SEND A 401 UNAUTHORIZED OR SENDS A 400 BAD REQUEST RESPONSE (IF THE QUERY IS NOT PROVIDED)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.delete("/PRODUCT", cors(), (req, res) => {
    try {
        if (req.query.ID) { // IF THE ID IS PROVIDED
            if (IS_ADMIN(req.headers.token)) { // CHECKS IF THE TOKEN IS VALID AND IS ADMIN
                PRODUCTS = PRODUCTS.filter(product => product.ID !== req.query.ID); // DELETES THE PRODUCT
                UPDATE_DATA("./databases/PRODUCTS.json", PRODUCTS); // UPDATES THE DATABASE
                res.status(204).send("NO CONTENT"); // SENDS A 204 NO CONTENT RESPONSE
            } else { // IF THE TOKEN IS NOT VALID
                res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
            }
        } else if (req.query.NAME) { // IF THE NAME IS PROVIDED
            if (IS_ADMIN(req.headers.token)) { // CHECKS IF THE TOKEN IS VALID AND IS ADMIN
                PRODUCTS = PRODUCTS.filter(product => product.NAME !== req.query.NAME); // DELETES THE PRODUCT
                UPDATE_DATA("./databases/PRODUCTS.json", PRODUCTS); // UPDATES THE DATABASE
                res.status(204).send("NO CONTENT"); // SENDS A 204 NO CONTENT RESPONSE
            } else { // IF THE TOKEN IS NOT VALID
                res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
            }
        } else { // IF THE ID AND NAME ARE NOT PROVIDED
            res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// AUTHENTICATES THE USER: /USER?NAME=:NAME&PASSWORD=:PASSWORD
// IF THE NAME AND PASSWORD ARE PROVIDED, CHECKS IF THE NAME AND PASSWORD ARE CORRECT; IF THEY ARE CORRECT, SENDS A 200 OK RESPONSE AND USER (REPLACING THE PASSWORD FIELD WITH THE TOKEN); OTHERWISE, SEND A 401 UNAUTHORIZED RESPONSE (BAD PASSWORD) OR A 400 BAD REQUEST RESPONSE (NO NAME OR PASSWORD PROVIDED) OR 404 NOT FOUND RESPONSE (NAME NOT FOUND)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.get("/USER", cors(), (req, res) => {
    try {
        if (req.query.NAME && req.query.PASSWORD) { // IF THE NAME AND PASSWORD ARE PROVIDED
            let DATABASE_USER = USERS.find(user => user.NAME === req.query.NAME); // FINDS THE USER WITH THE PROVIDED NAME
            let RECEIVED_USER = { // CREATES A RECEIVED USER OBJECT
                NAME: req.query.NAME,
                PASSWORD: req.query.PASSWORD
            }
            if (DATABASE_USER) { // IF THE USER IS FOUND
                let DATABASE_GENERATED_USER = VALIDATE(DATABASE_USER.TOKEN); // VALIDATES THE USER TOKEN
                if (DATABASE_GENERATED_USER) { // IF THE USER TOKEN IS VALID
                    if (DATABASE_GENERATED_USER.NAME === RECEIVED_USER.NAME && DATABASE_GENERATED_USER.PASSWORD === RECEIVED_USER.PASSWORD) { // IF THE NAME AND PASSWORD ARE CORRECT
                        res.status(200).send(DATABASE_USER); // SENDS A 200 OK RESPONSE WITH THE USER
                    } else { // IF THE NAME AND PASSWORD ARE NOT CORRECT
                        res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
                    }
                } else { // IF THE USER TOKEN IS NOT VALID
                    res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
                }
            } else { // IF THE USER IS NOT FOUND
                res.status(404).send("NOT FOUND"); // SENDS A 404 NOT FOUND RESPONSE
            }
        } else {
            res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// ADD A USER: /USER
// BODY: {
//     "NAME": "",
//     "PASSWORD": "",
//     "PASSWORD_CONFIRMATION": ""
// }
// IF THE NAME, PASSWORD, AND PASSWORD CONFIRMATION ARE PROVIDED, CHECKS IF THE NAME IS ALREADY TAKEN; IF IT IS NOT TAKEN, AND THE PASSWORD AND PASSWORD CONFIRMATION ARE THE SAME, AND IF THE NAME IS LONGER THAN 3 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), AND IF THE PASSWORD IS LONGER THAN 8 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), ADDS THE USER TO THE DATABASE, AND SENDS A 201 OK CREATED RESPONSE AND THE TOKEN; OTHERWISE, SEND A 400 BAD REQUEST RESPONSE (NO NAME, PASSWORD, OR PASSWORD CONFIRMATION PROVIDED) OR A 409 CONFLICT RESPONSE (NAME ALREADY TAKEN) OR A 401 UNAUTHORIZED RESPONSE (PASSWORD AND PASSWORD CONFIRMATION ARE NOT THE SAME) OR A 422 UNPROCESSABLE ENTITY RESPONSE (NAME IS SMALLER THAN 3 CHARACTERS OR ITS  EMPTY, NULL OR WHITE SPACE OR THE PASSWORD IS SMALLER THAN 8 CHARACTERS OR IF ITS EMPTY, NULL OR WHITE SPACE)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.post("/USER", cors(), (req, res) => {
    try {
        if (req.body.NAME && req.body.PASSWORD && req.body.PASSWORD_CONFIRMATION) { // IF THE NAME, PASSWORD, AND PASSWORD CONFIRMATION ARE PROVIDED
            let USER = USERS.find(user => user.NAME === req.body.NAME); // FINDS THE USER WITH THE PROVIDED NAME
            if (!USER) { // IF THE USER IS NOT FOUND
                if (req.body.PASSWORD === req.body.PASSWORD_CONFIRMATION) { // IF THE PASSWORD AND PASSWORD CONFIRMATION ARE THE SAME
                    if (req.body.NAME.trim().length > 3 && req.body.NAME.trim() !== "" && req.body.NAME.trim() !== null && req.body.PASSWORD.trim().length >= 8 && req.body.PASSWORD.trim() !== "" && req.body.PASSWORD.trim() !== null) { // IF THE NAME IS SMALLER THAN 3 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM), AND IF THE PASSWORD IS SMALLER THAN 8 CHARACTERS AND IF ITS NOT EMPTY, NULL OR WHITE SPACE (USING TRIM)
                        let USER = { // CREATES A USER
                            "NAME": req.body.NAME,
                            "PASSWORD": req.body.PASSWORD,
                            "IS_ADMIN": false
                        }; // END CREATES A USER
                        let TOKEN = jwt.sign(USER, process.env.SECRET_TOKEN); // CREATES A TOKEN
                        let NEW_USER_OBJECT = {
                            "NAME": USER.NAME,
                            "TOKEN": TOKEN,
                            "IS_ADMIN": USER.IS_ADMIN
                        }; // CREATES A NEW USER OBJECT (REPLACING THE PASSWORD FIELD WITH THE TOKEN)
                        USERS.push(NEW_USER_OBJECT); // ADDS THE USER TO THE DATABASE
                        UPDATE_DATA("./databases/USERS.json", USERS); // UPDATES THE USERS DATABASE
                        // CREATE A CART FOR THE USER AND ADD IT TO THE DATABASE
                        let CART = {
                            "TOKEN": TOKEN,
                            "PRODUCTS": []
                        }; // END CREATE A CART FOR THE USER AND ADD IT TO THE DATABASE
                        CARTS.push(CART); // ADDS THE CART TO THE DATABASE
                        UPDATE_DATA("./databases/CARTS.json", CARTS); // UPDATES THE CARTS DATABASE
                        res.status(201).send(NEW_USER_OBJECT); // SENDS A 201 OK CREATED RESPONSE AND THE USER (REPLACING THE PASSWORD FIELD WITH THE TOKEN)
                    } else {
                        res.status(422).send("UNPROCESSABLE ENTITY"); // SENDS A 422 UNPROCESSABLE ENTITY RESPONSE
                    }
                } else {
                    res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
                }
            } else {
                res.status(409).send("CONFLICT"); // SENDS A 409 CONFLICT RESPONSE
            }
        } else {
            res.status(400).send("BAD REQUEST"); // SENDS A 400 BAD REQUEST RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// GETS A GUN RELATED QUOTE: /QUOTE (NO AUTHENTICATION REQUIRED)
// MAKES A PUBLIC API RESQUEST (USING FETCH) AND SENDS A 200 OK RESPONSE AND THE QUOTE (IF THE QUOTE IS FOUND) OR A 404 NOT FOUND RESPONSE (IF THE QUOTE IS NOT FOUND)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.get("/QUOTE", cors(), (req, res) => {
    try {
        fetch(`https://api.quotable.io/random?minLength=110`) // MAKES A PUBLIC API RESQUEST (USING FETCH).
        .then(res => res.json()) // CONVERTS THE RESPONSE TO JSON
        .then(json => { // GETS THE JSON RESPONSE
            res.status(200).send({
                "QUOTE": json.content,
                "AUTHOR": json.author
            }); // SENDS A 200 OK RESPONSE AND THE QUOTE (IF THE QUOTE IS FOUND)
        }).catch(error => {
            res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
            console.warn(error); // LOGS THE ERROR
        }); // END MAKES A PUBLIC API RESQUEST (USING FETCH)
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// GET A USERS CART: /CART (AUTHENTICATION REQUIRED)
// GETS A USERS CART AND SENDS A 200 OK RESPONSE AND THE CART (IF THE CART IS FOUND) OR A 404 NOT FOUND RESPONSE (IF THE CART IS NOT FOUND)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.get("/CART", cors(), (req, res) => {
    try { // ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
        let TOKEN = req.headers.token; // GETS THE TOKEN FROM THE REQUEST HEADERS
        if (VALIDATE(TOKEN)) { // IF THE TOKEN IS VALID, GETS THE CART ASSOCIATED WITH THE TOKEN
            let CART = CARTS.find(cart => cart.TOKEN === TOKEN); // GETS THE CART ASSOCIATED WITH THE TOKEN
            if (CART) { // IF THE CART IS FOUND
                res.status(200).send(CART); // SENDS A 200 OK RESPONSE AND THE CART
            } else { // IF THE CART IS NOT FOUND
                res.status(404).send("NOT FOUND"); // SENDS A 404 NOT FOUND RESPONSE
            }
        } else { // IF THE TOKEN IS NOT VALID
            res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// ADDS A PRODUCT TO A USERS CART: /CART (AUTHENTICATION REQUIRED)
// PRODUCT: {
//    "ID": "",
//    "NAME": "",
//    "PRICE": ""
//}
// ADDS A PRODUCT TO A USERS CART (UPDATES THE DATABASE) AND SENDS A 201 OK CREATED RESPONSE OR A 404 NOT FOUND RESPONSE (IF THE PRODUCT IS NOT ADDED)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.post("/CART", cors(), (req, res) => {
    try { // ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
        let TOKEN = req.headers.token; // GETS THE TOKEN FROM THE REQUEST HEADERS
        if (VALIDATE(TOKEN)) { // IF THE TOKEN IS VALID, ADDS THE PRODUCT TO THE CART ASSOCIATED WITH THE TOKEN
            let CART = CARTS.find(cart => cart.TOKEN === TOKEN); // GETS THE CART ASSOCIATED WITH THE TOKEN
            if (CART) { // IF THE CART IS FOUND
                CART.PRODUCTS.push(req.body); // ADDS THE PRODUCT TO THE CART
                UPDATE_DATA("./databases/CARTS.json", CARTS); // UPDATES THE CARTS DATABASE
                res.status(201).send("OK CREATED"); // SENDS A 201 OK CREATED RESPONSE
            } else { // IF THE CART IS NOT FOUND
                res.status(404).send("NOT FOUND"); // SENDS A 404 NOT FOUND RESPONSE
            }
        } else { // IF THE TOKEN IS NOT VALID
            res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// REMOVES A PRODUCT FROM A USERS CART: /CART (AUTHENTICATION REQUIRED)
// PRODUCT: {
//    "ID": "",
//    "NAME": "",
//    "PRICE": ""
//}
// REMOVES A PRODUCT FROM A USERS CART (UPDATES THE DATABASE) AND SENDS A 204 NO CONTENT RESPONSE OR A 404 NOT FOUND RESPONSE (IF THE PRODUCT IS NOT REMOVED)
// ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
app.delete("/CART", cors(), (req, res) => {
    try { // ALWAYS ENVOLVE THE RESPONSE IN A TRY CATCH BLOCK TO CATCH ANY ERRORS AND SEND A 500 INTERNAL SERVER ERROR RESPONSE INSTEAD
        let TOKEN = req.headers.token; // GETS THE TOKEN FROM THE REQUEST HEADERS
        if (VALIDATE(TOKEN)) { // IF THE TOKEN IS VALID, REMOVES THE PRODUCT FROM THE CART ASSOCIATED WITH THE TOKEN
            let CART = CARTS.find(cart => cart.TOKEN === TOKEN); // GETS THE CART ASSOCIATED WITH THE TOKEN
            if (CART) { // IF THE CART IS FOUND
                CART.PRODUCTS = CART.PRODUCTS.filter(product => product.ID !== req.body.ID); // REMOVES THE PRODUCT FROM THE CART
                UPDATE_DATA("./databases/CARTS.json", CARTS); // UPDATES THE CARTS DATABASE
                res.status(204).send("NO CONTENT"); // SENDS A 204 NO CONTENT RESPONSE
            } else { // IF THE CART IS NOT FOUND
                res.status(404).send("NOT FOUND"); // SENDS A 404 NOT FOUND RESPONSE
            }
        } else { // IF THE TOKEN IS NOT VALID
            res.status(401).send("UNAUTHORIZED"); // SENDS A 401 UNAUTHORIZED RESPONSE
        }
    } catch (error) {
        res.status(500).send("INTERNAL SERVER ERROR"); // SENDS A 500 INTERNAL SERVER ERROR RESPONSE
    }
});

// REDITECTS ALL HTTP REQUESTS TO HTTPS REQUESTS
app.use((req, res, next) => {
    if (req.secure) { // IF THE REQUEST IS SECURE
        next(); // IF THE REQUEST IS SECURE
    } else { // IF THE REQUEST IS NOT SECURE
        res.redirect('https://' + req.headers.host + req.url); // REDITECTS ALL HTTP REQUESTS TO HTTPS REQUESTS
    } // END IF
}); // END REDITECTS ALL HTTP REQUESTS TO HTTPS REQUESTS
app.use(express.static('public')); // USES PUBLIC FOLDER

const SECURE_SERVER = https.createServer({
    key: fs.readFileSync('cert/key.pem'),
    cert: fs.readFileSync('cert/certificate.pem')
}, app)
SECURE_SERVER.listen(PORT, () => { // LISTENS TO PORT
    console.log(`RUNNING ON PORT: ${PORT}.`); // LOGS PORT
}); // END STARTS SERVER